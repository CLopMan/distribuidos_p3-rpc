\documentclass[]{article}
\usepackage{graphicx}
\usepackage[spanish]{babel}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}


\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{green},
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  showspaces=false,
  showstringspaces=false,
  tabsize=2,
  breaklines=true, captionpos=false,
}

%title
\title{Práctica 1} 

\author{Adrián Ferández Galán y César López Mantecón}

\begin{document}

\begin{titlepage}
    \centering
   \includegraphics[width=0.9\textwidth]{uc3m.jpg} 
    {\Huge Universidad Carlos III\\
    
     \Large Sistemas Distribuídos\\
     \vspace{0.5cm}
     Curso 2023-24}
    \vspace{2cm}

    {\Huge \textbf{Práctica 2} \par}
    \vspace{0.5cm}
    {\Large Sockets \par}
    \vspace{8cm}

   \textbf{Ingeniería Informática, Tercer curso}\\
    \vspace{0.2cm} 
    Adrián Fernández Galán (NIA: 100472182, e-mail: 100472182@alumnos.uc3m.es) \\
    César López Mantecón   (NIA: 100472092, e-mail: 100472092@alumnos.uc3m.es)
    \vspace{0.5cm}

   
    \textbf{Prof .} Félix García Caballeira y Alejandro Calderón Mateos\\
    
    \textbf{Grupo: } 81   
    
\end{titlepage}
\newpage

\renewcommand{\contentsname}{\centering Índice}
\tableofcontents

\newpage

\section{Introducción}
\label{sec:introduccion}
El desarrollo de este proyecto consiste en implementar una aplicación cliente-servidor, donde los diferentes clientes podrán guardar información en tuplas a través del servidor, de forma transparente. La comunicación entre el cliente y el servidor se dará a través de \textbf{llamadas a procedimientos remotos}. Los mensajes transmitidos deben ser independientes del lenguaje de programación. 

Cabe destacar que el tratamiento de peticiones en el lado del servidor será de forma concurrente, mediante el uso de procesos ligeros. 

\section{Diseño}
\label{sec:disenno}
La aplicación constará de dos partes diferenciadas: los clientes y el servidor.

\subsection{Cliente}
\label{subsec:cliente}
[modificar]
Siguiendo la misma aproximación que en el ejercicio anterior, el cliente no ha necesitado de cambios ya que la única parte afectada por los requisitos de este ejercicio es la comunicación. La comunicación entre el cliente y el servidor está completamente encapsulada en la biblioteca dinámica \textit{libclaves.so}. Por esto, se han utilizado los ficheros proporcionados por \textit{rpcgen} como plantilla, que sirven como código fuente de la bibliteca dinámica.

\subsection{Servidor}
\label{subsec:servidor}
En el servidor se encuentran las funcionalidades que se encargan de la comunicación con el cliente, en el fichero \textit{src/servidor.c}, y la implementación de los servicios para las tuplas, en el fichero \textit{src/imp\_clave.c}. De nuevo, el único archivo que necesitó de modificaciones es \textit{servidor.c} en la que se adaptan los contenidos de la plantilla dada por \textit{rpcgen}. 

\subsubsection{Implementación en el servidor}
\label{subsec:implementacion_servidor}

La implementación de los servicios requeridos está contenida en el fichero \textit{src/imp\_claves.c}. Dado que los servicios coinciden exáctamente con los del ejercicio anterior, este fichero no ha sufrido ningún cambio. Se compilará junto con el servidor. 

Siguiendo la misma idea que en la práctica anterior, guardaremos las tuplas en ficheros dado su caracter permanente entre sesiones y las facilidades que presentan para la gestión de la concurrencia.

\subsubsection{Concurrencia del Servidor}
\label{subsec::concurrencia_servidor}


\subsection{Comunicación}
\label{subsec:comunicacion}
La comunicación, tal y como especificamos anteriormente, se realiza a través de \textit{llamadas a procesos remotos}. Este mecanismo permite comunicar dos procesos cualesquiera en la misma red, independientemente de la arquitectura de la máquina que los ejecuta o el lenguaje de programación en el que esté escrita la aplicación. Es por esto que es importante que la información transmitida por las partes cliente y servidor de nuestro sistema sea también independiente de estos menesteres. 

\subsubsection{Interfaz.x}
\label{subsec:interfaz.x}
Para hacer los mensajes independientes del lenguaje de programación o arquitectura de la máquina, transmitiremos la información como cadenas de texto. Además, los mensajes serán transmitidos byte a byte para evitar la problemática presentada por la diferencia entre  arquitecturas \textit{little-endian} y \textit{big-endian}.

\subsubsection{Modificación de la plantilla}
\label{subsec::modificacion_plantilla}

\section{Compilación}
\label{sec:compilacion}
En esta sección se describe la forma de compilar el proyecto para generar dos ejecutables cliente y servidor.


Todos los comandos que se exponen a continuación quedan recogidos en un archivo \textit{Makefile} encargado de generar ambos ejecutables. 

\subsection{Biblioteca Dinámica}
\label{subsec:biblioteca}
Tal y cómo hemos descrito anteriormente, el código fuente de la biblioteca dinámica está contenido en el archivo \textit{claves.c}. Para compilarlo como una biblioteca dinámica se han empleado los siguientes comandos.

\begin{center}
\begin{lstlisting}[caption=Compiación de biblioteca dinámica]
\# código objeto
gcc -c -fPIC claves.c
\# biblioteca dinámica
gcc -shared -o libclaves.so claves.o
\end{lstlisting}
\end{center}

Con estos comandos generamos un archivo de código para enlazar con otro ejecutable. Este código será independiente de la posición. 

\subsection{Cliente}
\label{subsec:cliente}
El código fuente del cliente está contenido en el archivo \textit{cliente.c}. Este se compila enlazándolo con la biblioteca dinámica a través de los siguientes comandos: 

\begin{center}
\begin{lstlisting}[caption=Compiación de biblioteca dinámica]
\# generacion del objeto
gcc -c cliente.c

\# generar ejecutable con biblioteca dinámica
gcc -L. -Wl,-rpath=. -lclaves -o cliente cliente.o
\end{lstlisting}
\end{center}


\section{Descripción de pruebas}
\label{sec:descripcion_de_pruebas}
Para validar el correcto funcionamiento del sistema, hemos realizado dos bloques de pruebas. 

El primero, encargado de comprobar la implementación y concurrencia del sistema, reutiliza las pruebas desarrolladas para la primera parte. El resultado de estas pruebas es exitoso, tal y como esperábamos ya que no hemos modificado la implementación de los servicios.

Para el segundo bloque, encargado de comprobar la comunicación y correcta serialización de los datos, hemos conectado dos máquinas distintas (una lanzando el servidor y otra varios clientes) en una misma red LAN. El resultado de estas pruebas también ha sido exitoso.

\section{Conclusiones}
\label{sec:conclusiones}
Este ejercicio nos ha permitido explorar una nueva aproximación para el desarrollo de aplicaciones distribuídas, la llamada a procedimientos remotos. Esta forma de desarrollo nos permite una mayor abstracción, ayudándonos de herramientas de generación de código automático. 

La herramienta utilizada, aunque algo tosca, nos ofrece las mismas ventajas que el desarrollo con sockets pero con una sintaxis más sencilla y reduciendo el tiempo de codificación. Sin embargo, esto no quita la necesidad de revisar el código generado y adaptarlo a las necesidades concretas de la aplicación. 

El desarrollo de esta práctica, junto con las dos anteriores, nos ha permitido explorar diversos mecanismos de comunicación, cada uno con sus particularidades. Esto nos ha permitido afianzar las bases en la programación de aplicaciones distribuídas, dándonos las herramientas suficientes para afrontar el desarrollo de la práctica final. 

\end{document}
